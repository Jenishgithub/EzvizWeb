<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>EZVIZ Live</title>
  <style>
    body {
      margin: 0;
      background: black;
      color: white;
      font-family: Arial, sans-serif;
    }
    #container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #video {
      flex: 1;
      background: black;
    }
    #controls {
      padding: 15px;
      background: #222;
      border-top: 1px solid #444;
    }
    .control-group {
      margin-bottom: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    input[type="text"] {
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #333;
      color: white;
      min-width: 150px;
    }
    button {
      padding: 8px 16px;
      background: #0066cc;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background: #0052a3;
    }
    button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    #status {
      font-size: 12px;
      color: #aaa;
    }
    .error {
      color: #ff6b6b;
    }
    .success {
      color: #51cf66;
    }
    select {
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #333;
      color: white;
    }
  </style>
</head>
<body>
<div id="container">
  <video id="video" autoplay playsinline muted></video>
  <div id="controls">
    <div class="control-group">
      <label>Camera IP:</label>
      <input type="text" id="cameraIp" placeholder="e.g., 192.168.1.4" value="192.168.1.4">
      <button id="scanBtn" onclick="scanForCameras()">üîç Scan Network</button>
      <select id="cameraList" onchange="selectCamera()" style="display: none;"></select>
    </div>
    <div class="control-group">
      <label>Server IP:</label>
      <input type="text" id="serverIp" placeholder="e.g., 192.168.1.6" value="192.168.1.6">
      <label>Stream Path:</label>
      <input type="text" id="streamPath" placeholder="e.g., ezviz" value="ezviz" style="min-width: 100px;">
      <button onclick="startStream()">‚ñ∂ Connect</button>
    </div>
    <div id="status">Ready</div>
  </div>
</div>

<script>
// Configuration constants
const CONFIG = {
  DISCOVERY_SERVER: 'http://localhost:3000',
  MEDIAMTX_PORT: 8889,
  STUN_SERVER: 'stun:stun.l.google.com:19302'
};

let pc = null;
let scannedCameras = [];

// Start MediaMTX when page loads
async function initializeMediaMTX() {
  try {
    setStatus('‚è≥ Starting MediaMTX server...', 'info');
    const response = await fetch(`${CONFIG.DISCOVERY_SERVER}/start`, { method: 'POST' });
    const data = await response.json();
    
    if (data.status === 'success') {
      console.log('‚úÖ MediaMTX started:', data);
      setStatus('üì∫ MediaMTX started - Ready to stream', 'success');
      // Give MediaMTX time to start
      setTimeout(() => {
        setStatus('Ready. Scan network or enter server IP.', 'info');
      }, 2000);
    } else if (data.status === 'already_running') {
      console.log('‚ö†Ô∏è MediaMTX already running');
      setStatus('MediaMTX already running', 'info');
    } else {
      throw new Error(data.error || 'Failed to start MediaMTX');
    }
  } catch (error) {
    console.error('Error starting MediaMTX:', error);
    setStatus(`‚ö†Ô∏è Could not auto-start MediaMTX: ${error.message}`, 'warning');
  }
}

// Stop MediaMTX when page unloads
async function shutdownMediaMTX() {
  try {
    console.log('Stopping MediaMTX...');
    await fetch(`${CONFIG.DISCOVERY_SERVER}/stop`, { method: 'POST', keepalive: true });
  } catch (error) {
    console.error('Error stopping MediaMTX:', error);
  }
}

// Load saved config on page load
function loadConfig() {
  const savedCameraIp = localStorage.getItem('cameraIp');
  const savedServerIp = localStorage.getItem('serverIp');
  const savedStreamPath = localStorage.getItem('streamPath');
  
  if (savedCameraIp) {
    document.getElementById('cameraIp').value = savedCameraIp;
  }
  if (savedServerIp) {
    document.getElementById('serverIp').value = savedServerIp;
  }
  if (savedStreamPath) {
    document.getElementById('streamPath').value = savedStreamPath;
  }
}

// Save configuration
function saveConfig() {
  localStorage.setItem('cameraIp', document.getElementById('cameraIp').value);
  localStorage.setItem('serverIp', document.getElementById('serverIp').value);
  localStorage.setItem('streamPath', document.getElementById('streamPath').value);
}

// Update status message
function setStatus(message, type = 'info') {
  const statusDiv = document.getElementById('status');
  statusDiv.textContent = message;
  statusDiv.className = type;
}

// Scan network for cameras with RTSP port open
async function scanForCameras() {
  const scanBtn = document.getElementById('scanBtn');
  
  scanBtn.disabled = true;
  setStatus('‚è≥ Scanning network...', 'info');
  
  try {
    const response = await fetch(`${CONFIG.DISCOVERY_SERVER}/scan`);
    const data = await response.json();
    
    if (data.error) {
      throw new Error(data.error);
    }
    
    scannedCameras = data.cameras;
    
    if (scannedCameras.length === 0) {
      setStatus('‚ùå No cameras found. Please enter IP manually.', 'error');
    } else {
      // Show dropdown with found cameras
      const cameraList = document.getElementById('cameraList');
      cameraList.innerHTML = '<option value="">-- Select Camera --</option>';
      scannedCameras.forEach(ip => {
        const option = document.createElement('option');
        option.value = ip;
        option.textContent = `Camera at ${ip}`;
        cameraList.appendChild(option);
      });
      cameraList.style.display = 'inline-block';
      setStatus(`‚úÖ Found ${scannedCameras.length} device(s) with RTSP port open.`, 'success');
    }
  } catch (error) {
    setStatus(`‚ùå Scan error: ${error.message}. Make sure discovery server is running.`, 'error');
    console.error('Scan error:', error);
  } finally {
    scanBtn.disabled = false;
  }
}

// Select camera from dropdown
function selectCamera() {
  const cameraList = document.getElementById('cameraList');
  if (cameraList.value) {
    document.getElementById('cameraIp').value = cameraList.value;
  }
}

// Start WebRTC stream
async function startStream() {
  const serverIp = document.getElementById('serverIp').value.trim();
  const streamPath = document.getElementById('streamPath').value.trim();
  
  if (!serverIp || !streamPath) {
    setStatus('‚ùå Please enter both Server IP and Stream Path', 'error');
    return;
  }
  
  // Save for next time
  saveConfig();
  
  const WHEP_ENDPOINT = `http://${serverIp}:${CONFIG.MEDIAMTX_PORT}/${streamPath}/whep`;
  
  try {
    setStatus('‚è≥ Connecting to ' + serverIp + '...', 'info');
    
    // Close previous connection
    if (pc) {
      pc.close();
    }
    
    // Create new peer connection
    pc = new RTCPeerConnection({
      iceServers: [{ urls: [CONFIG.STUN_SERVER] }]
    });
    
    const video = document.getElementById('video');
    
    // Add video transceiver
    pc.addTransceiver('video', { direction: 'recvonly' });
    
    // Handle incoming video track
    pc.ontrack = (event) => {
      console.log('üìπ Track received:', event.track.kind);
      video.srcObject = event.streams[0];
      setStatus('üü¢ Connected - Streaming', 'success');
    };
    
    // Handle connection state changes
    pc.onconnectionstatechange = () => {
      console.log('Connection state:', pc.connectionState);
      switch (pc.connectionState) {
        case 'failed':
        case 'disconnected':
          setStatus('üî¥ Connection lost', 'error');
          break;
        case 'closed':
          setStatus('Connection closed', 'warning');
          break;
      }
    };
    
    // Handle ICE candidates
    pc.onicecandidate = (event) => {
      if (event.candidate) {
        console.log('üßä ICE candidate:', event.candidate.candidate);
      }
    };

    // Create and send offer
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    
    console.log('üì§ Sending offer to', WHEP_ENDPOINT);
    
    const res = await fetch(WHEP_ENDPOINT, {
      method: 'POST',
      headers: { 'Content-Type': 'application/sdp' },
      body: offer.sdp
    });

    if (!res.ok) {
      const errorText = await res.text();
      console.error('Server error:', errorText);
      throw new Error(`Server error: ${res.status} - ${errorText}`);
    }

    // Receive and set answer
    const answerSdp = await res.text();
    console.log('üì• Received answer');
    
    const answer = new RTCSessionDescription({
      type: 'answer',
      sdp: answerSdp
    });
    
    await pc.setRemoteDescription(answer);
    console.log('‚úÖ WebRTC connection established');
    
  } catch (error) {
    console.error('‚ùå Error:', error);
    setStatus('‚ùå Error: ' + error.message, 'error');
  }
}

// Load saved config on page load
window.addEventListener('load', () => {
  loadConfig();
  initializeMediaMTX();
});

// Stop MediaMTX when page unloads
window.addEventListener('beforeunload', shutdownMediaMTX);
window.addEventListener('unload', shutdownMediaMTX);

// Allow Enter key to start stream
document.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    startStream();
  }
});
</script>
</body>
</html>
